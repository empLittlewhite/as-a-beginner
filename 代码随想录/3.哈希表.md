---
date: 2024-10-23
aliases:
  - hash table
tags:
  - 算法
---

	什么时候会想到用hash呢

需要判断某个元素是否出现在某集合里


在[[入门篇]]

## 理论基础
懂的都懂

解决冲突的两种方法：拉链法、线性探测法（tablesize > datasize）

	常见的哈希结构

数组、set（集合）、map(映射)

- 三种set

![[Pasted image 20241023210135.png]]

- 如果修改红黑树的值会怎么样？
有序的树结构，修改值之后，会导致平衡二叉数的结构完全改变，所以不能轻易修改，只能删除和增加。
==尽量选择unordered_set

- 也有三种map呢！

![[Pasted image 20241023210601.png]]

只对key进行了约束，没有对value进行约束




## 有效的字母异位次

	题目说明

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

示例 2: 输入: s = "rat", t = "car" 输出: false

说明: 你可以假设字符串只包含小写字母。


	思路

暴力法非常复杂，还不如直接hash！
（数组就是一种特殊的hash）

一个数组存放各个字母出现的次数！
26个字母，

甚至可以一遍过！
遍历A字符串直接记录数组，判断B字符串，直接减掉其中的次数，最后判断数组是否为空

那这个hash函数怎么确定呢？？？
record[A[i]-'a']   可以记录小写字母的相对位置


```cpp
class Solution{
public:
	bool isThesame(string A, string B){
	int record[26] = {0};
	for(int i = 0; i < A.size(); i++){
		record[A[i]-'a']++;
	} 
	for(int i = 0; i < B.size(); i++){
		record[B[i]-'a']--;
	} 
	for(int i = 0; i < 26; i++){
		if(record[i] != 0){
			return false;
		}
	} 
	return true;
	}


}




```



## 两个数组的交集

给定两个数组，编写一个函数来计算它们的交集，元素唯一，不考虑结果有序。

最后的元素是唯一的，要首先各自去重！，然后再计算交集

使用数组计算吗？
如果规定在了26个字母，那确实可以，但是呢没给元素范围，咋说呢？

可以使用set
（set有三种呢！
红黑树（平衡二叉树-不能修改，元素有序）：集合set-元素唯一，multiset-元素不唯一，
unordered_set-可以修改）

```cpp
class Solution{
public:
	//交叉的部分叫：intersection
	vector<int> intersection(vector<int> &nums1;vector<int> &nums2){
		unordered_set<int> result_set;//存放结果
		unordered_set<int> nums_set(nums1.begin(),nums1.end())；//将nums1先去重,从头到尾,通过迭代器实现，构造函数的一个功能
		for(int num:nums2){
		//遍历数组nums2，只要发现，使用 `find` 方法检查当前遍历到的元素 `num` 是否存在于 `nums_set` 中。如果 `find` 方法返回的迭代器不等于 `end` 迭代器，说明元素在 `nums_set` 中找到了
			if(nums_set.find(num) != nums_set.end()){
			result_set.insert(num);
			}
		}
		return vector<int> (result_set.begin(),result_set.end())
	}

};
```


## 快乐数

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False 。

	小心无限循环，直接裂开
只能将这类的数存起来，之前遇到了就不能再循环了！


```cpp
# 解耦合，小功能封装成小函数


class Solution{
public:
	//如何计算各位平方之和？逐渐除10变小
	int getSum(int n){
		int sum = 0;
		while(n){
			//取余，对最小位的数求平方
			sum += (n % 10)*(n % 10);
			n /= 10;
		}
		return sum;
	}
	
	bool isHappyNum(int num){
		unordered_set<int> set;
		//需要一直循环，但是没有啥进入条件，但是有跳出条件
		//把while(n)作为条件可以吗？？？？
		
		while(1){
			int sum = getSum(n);
			if(sum == 1){
				return true;
			}
			if(set.find(sum) != set.end()){
				return flase;
			}else{
				set.insert(sum);
			}
			n = sum;//需要更新值！
		}
		
	}
	

};
```


	写算法答题的时候，什么时候需要传入int n，啥时候需要传入 int &n呢

取决于函数---参数 需要做怎样的交互？？？
如果需要修改外部变量---&引用，比如两个数组求intersection，每个数组都去重了！
只是得到一个返回值--- int n

//思考nums需要&吗？好像一般int都不用，但是数组啥的就需要&


## 两数之和

就是hot100的第一题
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

**示例:**

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]


	思考如何使用哈希完成

只循环一遍？空间换时间？
这里需要记录一对元素，值and位置，可以考虑用map
尽量不用有序，因为unordered_map效率更高

逆向思维：查一个元素num，再查一下target-num 是否出现过！

```cpp
class Solution{
public:
//思考nums需要&吗？好像一般int都不用，但是数组啥的就需要&
	vector<int> twoSum(vector <int>&nums,int target){
		unordered_map <int,int> map;
		for(int i = 0; i < nums.size(); i++){
		//不知道返回值是什么类型  用auto!
			auto it = map.find(target - nums[i]);
			if(it != map.end()){
				//立刻返回现在的
				return {it->second,i};
			}
			map.insert(pair<int,int>(nums[i],i));
		}
		return {};//没有要返回空集的
	}

};


```



## 四数相加



## 赎金信



## 三数之和



## 四数之和




## 总结

