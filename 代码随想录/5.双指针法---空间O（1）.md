
和字符串的内容高度重合！

一个快指针，一个慢指针
快指针的作用：把容器内元素都遍历一下
慢指针：遇到需要处理的元素，将其和慢指针此时的位置产生联系

## 移除元素

	题目描述

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

**你不需要考虑数组中超出新长度后面的元素。**

```cpp
class Solution{
public:
	int removeElement(vectorr<int> &nums,int val){
		//跑在最前面
		int slowIndex = 0;
		for(int fastIndex = 0; fastIndex < nums.size();fastIndex++){
		if(val != nums[fastIndex]){
			nums[slowIndex++] = nums[fastIndex]
		}
		}
		return slowIndex;
	}
};
```




## 反转字符串



直接用reverse？？？

	关于库函数的使用

算法的关键是reverse，自己手写reverse
不关键，就可以使用reverse


```cpp
class Solution{
public:
	void reverse(vector<char>& s){
		for(int i=0,j = s.size() -1; i < s.size()/2;i++){
			swap(s[i],s[j]);
		}
	}

};


```


## 替换数字

	题目描述
给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。

1.字符串的空间需要先扩容
2.还得从后往前 遍历修改？？？

因为不需要申请新的数组，而且也不需要移动前一个遇到数字后移  新添加number的操作

```cpp
#include <iostream> 
using namespace std;

int main(){
	string s;
	cin >> s;
	//首先需要统计数字的数量，便于扩容
	while(s){
		for(auto & i:s){
		//判断是否为数字
			if(s[i] >='0' && s[i] <='9' ){
				count++;
			}
		}
	}
	//开始扩容
	int sOldIndex = s.size()-1;
	s.resize(s.size() + count * 5);//6-1=5
	//开始从后往前 数字改number
	int sNewIndex = s.size()-1;
	while(sOldIndex >=0){
		if(s[sOldIndex]>='0'&& s[i] <='9'){
			s[sNewIndex--] = 'r';
			s[sNewIndex--] = 'e';
			s[sNewIndex--] = 'b';
			s[sNewIndex--] = 'm';
			s[sNewIndex--] = 'u';
			s[sNewIndex--] = 'n';
		}else{
			s[sNewIndex--]= s[sOldIndex--];
		}
		sOldIndex--;
	}
	cout << s <<endl;
	return 0;
}
```



## 翻转字符串里的单词

	记录
(2024-11-18)每太看懂


	题目表述

给定一个字符串，逐个翻转字符串中的每个单词。

示例 1：  
输入: "the sky is blue"  
输出: "blue is sky the"

示例 2：  
输入: "  hello world!  "  
输出: "world! hello"  
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。


erase（）是O(n),删除之后还要把元素前移
再套一个循环，妥妥的O(n^2)


思想非常简单：双指针，一个在前跑，遇到空格，就删掉，
慢指针和快指针之间的元素进行翻转！

```cpp
#include <string>
#考虑resize()

class Solution{
public:
	void reverse(string &s,int start,int end){
		for(int i=start,j= end; i<j ;i++,j--){
			swap(s[i],s[j]);
		}
	
	}
	void removeExtraSpace(string&){
		int slow =0, fast=0;
		for(int fast=0; fast < s.size();fast ++){
			if(s[fastIndex]!= ' '){
			//这里的处理没有问题吗？
				if(slow != 0) s[slow++] = ' ';
				while(i < s.size() && s[i] != ' '){
					s[slow++] = s[fast++]; 
				}
			}
		s.resize(slow);
	}
	string reverseWords(string s){
		removeExtraSpace(s);
		reverse(s,0,size()-1);
		int start = 0;
		for(int i=0; i < s.size();i++){
			if(i == s.size || s[i] = '0'){
				reverse(s,start,i-1);
				//有空格，所以跳过
				start = i +1;
			}
		}
		return s;
	}

};




```

## 翻转链表

题意：反转一个单链表。

示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL

这个单链表是什么数据结构呢？？？
链表是靠头结点head定位的，定位带head就可以确定单链表
所以返回head*

```cpp

#pre指针
listNode* reverseList(listNode* head){
	ListNode* tmp;
	ListNode* pre=Null;
	ListNode* cur=head;
	while(cur){
		tmp = cur->next;//存储cur向右的指向
		cur->next=pre;//此时cur指向左侧啦？
		//现在更新pre的cur，都向后移动一下
		pre = cur;
		cur = temp;//再把cur的指向->
	}
	return pre；
}
```

## 删除链表的倒数第N个节点





## 链表相交





## 环形链表


## 三数之和



## 四数之和






## 总结



